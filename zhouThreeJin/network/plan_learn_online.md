# 概念  
![](./png/png1.jpeg)
场景：当搜索一个域名（绑定了一个ip地址）的时候。  
1.首先在本地缓存查收是否有域名对应的ip  

2.如果没有会去查找本地的host文件，查看是否有映射关系  

3.都没有的话就会发送一个dns请求，这个是后五层网络模型所做的事情：从上往下封装      
应用层——— 生成一段'请告诉我baidu.com的ip的地址'    
传输层——— 对应用层数据进行封装生成原端口和目的端口（TCP/UDP传输协议）     
网络层——— 封装原ip和目的ip   
数据链路层 —— 当在这私网段找不到目的ip地址的时候就会去寻找网关（路由器），默认网关ip192.168.1.1,会添加网关的mac地址和本机mac地址    
物理层—— 通过网卡发送出去  

4.如果发送到交换机上（只有两层模型）从下往上解封  
物理层
数据链路层 —— 解析mac地址确实挂载自己端口两边进行转发

5.发送到路由器 （有三层模型）从下往上解封  
物理层
数据链路层 —— 发现这个目的mac地址就是自己，就接受数据包然后往上传到网络层  
网络层 —— 先通过查找路由表发现没有对应的ip，会发送到默认路由上（如果同样没有），就会从WAN口转发到公网上。这里面其中有个NAT地址映射表（会保存私网ip和端口以及对应公网的ip和端口），然后对这个请求的ip和端口、原mac地址、目的mac地址改为公网的ip和端口、本机的mac地址、规定转发到的路由mac地址    

6.进过互联网发送到dns服务器（应用层的）从下往上，每经过一个路由器就会修改相应的mac地址（原mac地址、目的mac地址）  最终确定ip相同、端口对应 就是发送给他的  

# GFW防火墙  
场景   
![](./png/png2.jpeg)  
  
定义：当国内访问国外数据的时候中间有道防火墙（GFW）它可以查看你数据包里面的内容。五层结构。    
问题1:  
因此可以将返回的数据包内容进行篡改——将返回的应用层数据里面的ip地址篡改（DNS污染/劫持）。      
解决办法：   
1.直接在host文件中添加ip地址和域名——不发送请求  
问题2:  
应用层的HTTP请求是基于TCP（有连接）的，但是GFW有黑名单ip出现在里面的话就会被干掉，无法到达。或者防火墙伪装成为服务器给你返回一个数据包（伪造）————TCP重制攻击  

问题3:  
因为存在其他的DNS解析ip，所以有可能会有数据包建立TCP连接。之后发送的请求任然被GFW检查，发现里面存在黑名单的域名（应用层）就会再次拦截。  

问题4:  
通过代理的方式，如http、socks5因为这个在墙外的服务器，国内可以连接，但是因为GFW可以查看应用层的东西所以任然会出现问题——甚至会把这个服务器的ip加入黑名单中。  

——————————  
综上的大部分原因都是因为：GFW可以查看到应用层的东西  
因此vpn可以实现的就是加密，但是传统vpn连接（IPSec openvpn  协议）的时候会在应用层表明要进行vpn连接，这个时候GFW并不会直接阻断，而是先允许你，但是会进行监控，在长时间大流量、和特殊时期就会可能进行关闭。————特征明显    
shadowsocks协议——不仅完成了加密而且没有那么明显的特征   
步骤：1.首先在服务端搭建ss服务监听8388端口的  
2.在本机上运行ss服务的客户端，监听端口1080（接受数据）  
3.对浏览器设置代理（浏览器的请求会先走这个端口）端口1080   
4.发送http请求的时候会先进过ss代理进行加密，从而使应用层加密，然后进过五层模型发送到互联网上。  
5.服务端解密并且进行带替去访问相对应的服务。然后对返回的数据也在应用层进行加密，在放回互联网。    
缺点：GFW可以实现主动探索从而试探出使用的是哪一种协议  

# 搭建节点    
VPS：一台24小时不关机的虚拟电脑——会给你分配一个公网ip。 
如果你的vps是window系统的话就可以使用FinalShell 进行管理连接3389端口来进行管理

1.ubuntu搭建shadowsocks  
```
apt install shadowsocks-libev   #下载服务

vim /etc/shadowsocks-libev/config.json #搭配配置文件  

{
    "server":{"::1","127.0.0.1"}, //127.0.0.1  表示的是只接受本地回环的ip地址，就是只接受在本机中的流量（如果有多个公网ip的时候这个就很有用），改为0.0.0.0可以接受所有ip的信息   
    "mode":"tcp_and_udp",
    "server_port":8388,
    "local_port":1080, 
    "password:"hss12",
    "timeout":86400,
    "method":"chacha20-ietd-poly1305"
}
___________________________________________
            //改为
{
    "server":{"0.0.0.0"},   
    "mode":"tcp_and_udp",
    "server_port":8388,
    "local_port":1080, 
    "password:"hss12",
    "timeout":86400,
    "method":"chacha20-ietd-poly1305"  //加密方式
}
```  

问题5:  
GFW利用你的东西给同一台服务器发送相同的数据查看里面返回的数据是什么——查看运行的是什么服务（重放攻击）  

2.关闭服务端防火墙/开放端口运行对外访问  
`ufw allow 8388`  

3.查看日志  
`journalctl -u shadowsocks-libev.service -f `  
查看发现无法ping通并且日志没有更新内容————很大程度被GFW给阻隔了  
可以尝试更换端口  
发送成功后会看到  
![](./png/png3.jpeg)
这里面就会有一个不属于本机的ip去发送请求（重放攻击）  

4.在ss协议之后加上plugin（插件）  
原理：是在原本的数据基础上添加一些流量头，使这些流量伪装成为一个正常/合理的流量从而实现GFW不会重放攻击。之后服务端也使用这个插件进行解封在通过ss服务端的到真正的数据  

`apt install shadowsocks-v2ray-plugin` 安装插件  
`dpkg -L` 查看安装了什么内容  
`ss-v2ray-plugin` 可以直接使用但是没有配置，所以启动也没什么用  
`vim /etc/shadowsocks-libev/config.json `修改配置文件添加插件
{
    "server":{"0.0.0.0"},   
    "mode":"tcp_and_udp",
    "server_port":8388,
    "local_port":1080, 
    "password:"hss12",
    "timeout":86400,
    "method":"chacha20-ietd-poly1305"  //加密方式
    "plugin":"ss-v2ray-plugin" //添加插件
    "plugin_opts":"server"  
}

![](./png/png4.jpeg)  
插件选项为"server"其他一致  
其中客户端的配置中的端口为1080相当于在本机中再使用一个代理ip为127.0.0.1  
  

# trojan的原理  
http原理： 是明文的任何中间的服务器都可以对我们的数据进行添加、修改  


